using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace TestsGenerator
{
    public class TestGenerator
    {
        private Random rnd = new Random();
        private List<MethodDeclarationSyntax> CreateMethods(ref List<ClassDeclarationSyntax> classes)
        {
            List<MethodDeclarationSyntax> newMethods = new List<MethodDeclarationSyntax>();
            foreach (var classDecl in classes)
            {
                var methods = classDecl.DescendantNodes()
                    .OfType<MethodDeclarationSyntax>()
                    .Where(method => method.Modifiers.
                    Where(modifier => modifier.IsKind(SyntaxKind.PublicKeyword)).Any()).ToList();

                if (methods.Count() == 0)
                {
                    return newMethods;
                }

                foreach (var method in methods)
                {
                    var body = SyntaxFactory.ParseStatement("Assert.Fail(\"autogenerated\");");
                    var newTestMethod = SyntaxFactory.MethodDeclaration(SyntaxFactory.ParseTypeName("void"), string.Concat(classDecl.Identifier, method.Identifier, "Test"))
                        .AddAttributeLists(SyntaxFactory.AttributeList((SyntaxFactory.SingletonSeparatedList(
                                SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("Test"))))))
                        .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                        .WithBody(SyntaxFactory.Block(body));
                    newMethods.Add(newTestMethod);
                }
            }

            return newMethods;
        }

        private ClassDeclarationSyntax CreateClass(ref List<ClassDeclarationSyntax> classes)
        {
            var testClass = SyntaxFactory.ClassDeclaration("MyTestClass" + rnd.Next(1, 100).ToString())
                .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
                .AddAttributeLists(SyntaxFactory.AttributeList((SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.Attribute(SyntaxFactory.IdentifierName("TestFixture"))))))
                .AddMembers(CreateMethods(ref classes).ToArray());

            return testClass;
        }

        public Task<Test> GetTests(string source)
        {
            if (source is null)
            {
                throw new ArgumentNullException(nameof(source));
            }

            if (source.Length == 0)
            {
                return Task.FromResult(new Test("Empty.cs"));
            }

            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(source);
            var root = syntaxTree.GetRoot();
            var classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();
            if (classes.Count() == 0)
            {
                return Task.FromResult(new Test("Empty.cs"));
            }

            var srcNamespace = (NamespaceDeclarationSyntax)(syntaxTree.GetCompilationUnitRoot().Members[0]);
            var name = srcNamespace.Name;
            var test = new Test(name.ToString() + rnd.Next(0, 100) + ".cs");
            var syntax = SyntaxFactory.CompilationUnit()
                .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")))
                .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("NUnit.Framework")))
                .AddUsings(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName(name.ToString())))
                .AddMembers(SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName(name.ToString() + ".Tests"))
                .AddMembers(CreateClass(ref classes)));
            test.code = syntax.NormalizeWhitespace().ToFullString();
            return Task.FromResult(test);
        }

        public class Test
        {
            public string fileName;
            public string code = string.Empty;

            public Test(string name)
            {
                fileName = name;
            }
        }
    }
}
